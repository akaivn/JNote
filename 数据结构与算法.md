# 数据结构与算法

## 1.简介

> 从广义上讲：数据结构就是一组数据的存储结构。算法就是操作一组数据的方法。

作为非算法工程师，并不需要 将所有的数据结构和算法全部掌握。只需要掌握以下罗列的10个 **数据结构** 和十个 **算法** 即可。

- 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树。
- 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

## 2.复杂度分析

> 想要学习数据结构与算法，必须要掌握复杂度分析。学好复杂度分析，会让你接下来的学习事半功倍。

在很多的算法书籍中，有一种这个的统计方法： **事后统计法**

- 将一段代码运行，然后通过统计、监控 就能得到算法的执行时间和占用的内存大小。

  （但是这种方法有很大的局限性）

  - 测试结果十分依赖于测试环境-->比如说一段代码在Inter Core i9处理器与Inter Core i3处理器的速度肯定是不一样的。
  - 测试结果受到数据量的影响-->比如说对一组数字进行排序，如果数据是事先排序好的 那么执行时间极短。有序度不一样，消耗的时间也不一样。小规模的数据，插入排序就比快排排序速度要快。

因此 不需要具体的进行测试，经过粗略计算得到 执行效率的方法，油然而生。

### 1.时间复杂度

如下面代码

（注：介于笔主是一个 java 开发工程师，以下代码演示 使用java语言）

```java
// 此方法的功能是 计算从 1加到n (1+2+3+..+n) 
private int count(int n){
     int sum = 0;
     for (int i = 1; i <= n; i++) {
         sum += i;
     }
     return sum;
 }
```

当代码开始运行的时候，**赋值**-**判断**-**计算**。尽管每一行的代码对应的CUP执行时间不一样。但是我们只是大概的进行估算，假设每行代码的运行速度都是一样的，都为time。

- 第3行代码是需要一个time，第4、5行代码运行了n次。故这段代码的执行时间就是(2n+1)*time
- 得出结论：**代码的执行时间 T(n) 与 每行的执行时间成正比**

按照这个思路，再看下面代码

```java
// 此方法的功能是 计算（1+2+3+..+n)*(1+2+3+..+n)
private int count(int n){
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                sum += i * j;
            }
        }
        return sum;
    }
```

依旧假设每行的代码需要一个time时间，那么T(n)是什么呢？

- 第3行需要一个time，第4、5、6行各需要一个time，故T(n)=3n<sup>2</sup>+1

> 尽管不知道 time的确切值，但是 综上所述，所有的执行时间T(n)与每行代码执行次数都是成正比。
>
> 故 可以将此规律 总结成一个 公式：T(n)=O(f(n))

- 比如说 例一：T(n)=O(2n+1)；例二：T(n)=O(3n<sup>2</sup>+1)。这就叫做 **大O时间复杂度表示法**。
- 大O时间复杂度表示法，并不是表示代码真正的执行时间，而是指 **代码执行时间随着数据规模增长的变化趋势** ，因此常常也被叫为**渐进时间复杂度**，简称 **时间复杂度**
- 但是当公式中的n十分大的时候，比如10000、100000。公式中的**低阶**、**常数**、**系数**部分并不能影响变化趋势，因此可以忽略。
- 比如说 例一：T(n)=O(n)；例二：T(n)=O(n<sup>2</sup>)；

#### 分析方法

1. 只关注于循环执行次数最多的一行代码

   ```java
   // 此方法的功能是 计算从 1加到n (1+2+3+..+n) 
   private int count(int n){
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += i;
        }
        return sum;
    }
   ```

   还是第一个例子，第3行只执行了一次，与n的大小无关。故只需要关注4、5行代码，执行了n次，所以总的时间复杂度是O(n)；

2. 加法法则：总复杂度等于量级最大的代码复杂度

   ```java
   private int count(int n){
           int sum = 0;
           // (1+2+3+..+88)
           for (int i = 1; i <= 88; i++) {
               sum += i;
           }
   
           // (1+2+3+..+n)
           for (int j = 1; j <= n; j++) {
               sum += j;
           }
   
           //（1+2+3+..+n)*(1+2+3+..+n)
           for (int i = 1; i <= n; i++) {
               for (int j = 1; j <= n; j++) {
                   sum += i * j;
               }
           }
           return sum;
       }
   ```

   这段代码 分为三个部分，第一段 计算从1加到88，第二段 计算从1加到n，第三段计算从1加到n再乘以1到n。

   - 第一段代码，代码执行了88次。与n的大小无关，是一个常数的执行时间。
   - 第二段代码，代码执行了n次。可以表示为O(n)
   - 第三段代码，代码执行了n<sup>2</sup>次。可以表示为O(n<sup>2</sup>)

   取其中最大的量级，第一部分的**常数**，和第二部分的**低阶**就省略了，总的时间复杂度 就是O(n<sup>2</sup>)

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

   ```java
   private int sum(int n){
       int result = 0;
       for (int i = 1; i <= n; i++) {
           result += count(i);
       }
       return result;
   }
   private int count(int n){
       int sum = 0;
       // (1+2+3+..+n)
       for (int i = 1; i <= n; i++) {
           sum += i;
       }
       return sum;
   }
   ```

   乘法法则 根据加法法则应该能猜出来吧。

   - 单看第3行的循环 会执行n次，记做T(1)=O(n)；单看第11行的循环 会执行n次，记做T(2)=O(n)；在第四行的时候，会调用第11行的循环。故sum() 方法的整体时间复杂度就等于T(n)=T(1)*T(2)=O(n<sup>2</sup>)；

4. 其他常见时间复杂度实例

   - 常数阶 O(1)

   - 对数阶 O(log n)

   - 线性阶 O(n)

   - 线性对数阶 O(n log n)

   - 平方阶 O(n<sup>2</sup>)、立方阶 O(n<sup>3</sup>)、...、k方阶 O(n<sup>k</sup>)

   - 指数阶 O(2<sup>n</sup>)

   - 阶乘阶 O(n!)

     1. O(1)

        它是一种常量级时间复杂度表示方法，并不是单指一行代码。例如下面代码，虽然它有四行代码，但是复杂度依旧是 O(1)

        ```java
        private int count(int n){
            int sum = 0;
            int i = 1;
            int j = 2;
            sum = i + j;
            return sum;
        }
        ```

        一般情况下，只要代码中没有循环，递归 即使是千万行代码，其时间复杂度也是O(1)

     2. O(log n)、O(n log n)

        对数阶比较难分析，但是也是十分常见的。

        ```java
        private int count(int n){
            int i = 1;
            while (i <= n){
                i *= 2;
            }
            return i;
        }
        ```
        
循环的作用：高中时期的等比数列,当 i <= n 的时候,就会不断乘以2 (2<sup>0</sup> 2<sup>1</sup> 2<sup>2</sup> 2<sup>3</sup> .. 2<sup>x</sup> = n)
        
注释中的x 就是循环次数，根据n求x值。x等于log以2为底n的对数。
        
故此方法的时间复杂度为 ：O（x=log<sub>2</sub>n）
        

        
```java
        // 将底数改变之后
        private int count(int n){
            int i = 1;
            while (i <= n){
                i *= 10;
            }
            return i;
        }
        ```
        
        将底数改变之后，方法的时间复杂度变为：O（x=log<sub>10</sub>n）。

        - 其实可以将这些对数阶都统称为 log n。
- 因为在高中数学 我们曾经学过这个公式：log<sub>10</sub>n = log<sub>10</sub>2 * log<sub>2</sub>n ;所以 log<sub>10</sub>n = O(C * log2n)，其中 C = log<sub>10</sub>2是一个常量，可以忽略。
        - 所以在对数中，忽略 '底数' ，统一表示为log n。
        - n log n的话，就是在一个循环里，执行了n次的log n ;跟乘法法则中的类似。
        
     3. O(m+n)、O(m*n)

        由两个数据的规模,老规矩 看代码

        ```java
   private int sum(int n, int m){
            int sum1 = 0;
            for (int i = 1; i <= n; i++) {
            	sum1 += i;
            }
        
            int sum2 = 0;
            for (int i = 1; i <= m; i++) {
                sum2 += i;
            }
            return sum1 + sum2;
        }
        ```
     
        从代码分析来看，第3行的循环执行了 n 次，第8行的循环执行了 m 次。因为 无法知道 m 或 n 的谁的量级比较大，所以无法使用加法法则进行取舍。

        T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

### 2.空间复杂度

前面曾经说过时间复杂度的全称是 渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

